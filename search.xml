<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决unable to find vcvarsall.bat问题]]></title>
    <url>%2F2019%2F09%2F08%2F%E8%A7%A3%E5%86%B3unable-to-find-vcvarsall-bat%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题在安装 Python 的第三方库或者编译源码的时候，相信不少人遇到过unable to find vcvarsall.bat 这个错误，网上也有不少的解决办法，但是自己操作一遍之后，发现问题还是没有解决，因此特意记录下我自己解决这个问题的方法。解决方案其实解决方法也很简单，有两种：安装 Visual Studio安装 Visual C++ Build ToolsVS Studio 比较庞大，是个重量级的大家伙，个人更偏向于安装 VC Build Tools，毕竟不是专门用 VS 开发的，安装之后可能需要重启一下系统。需要注意的是，VS/VC 的版本需要跟编译 Python 所用的 VS/VC 的版本对应, 比如 Python 3.4.1 是用 MSC v.1600 编译的，那么就需要安装 Visual Studio 2010 或者 Visual C++ 2010，可以去微软网站上找得到 MSC 的版本跟 VS/VC 对应关系。这里有一份不完整的列表可以参考：123456789101112131415161718MSC v.1000 -&gt; Visual C++ 4.x MSC v.1100 -&gt; Visual C++ 5 MSC v.1200 -&gt; Visual C++ 6 MSC v.1300 -&gt; Visual C++ .NET MSC v.1310 -&gt; Visual C++ .NET 2003 MSC v.1400 -&gt; Visual C++ 2005 (8.0)MSC v.1500 -&gt; Visual C++ 2008 (9.0)MSC v.1600 -&gt; Visual C++ 2010 (10.0)MSC v.1700 -&gt; Visual C++ 2012 (11.0)MSC v.1800 -&gt; Visual C++ 2013 (12.0)MSC v.1900 -&gt; Visual C++ 2015 (14.0)MSC v.1910 -&gt; Visual C++ 2017 (15.0)MSC v.1911 -&gt; Visual C++ 2017 (15.3)MSC v.1912 -&gt; Visual C++ 2017 (15.5)MSC v.1913 -&gt; Visual C++ 2017 (15.6)MSC v.1914 -&gt; Visual C++ 2017 (15.7)MSC v.1915 -&gt; Visual C++ 2017 (15.8)MSC v.1916 -&gt; Visual C++ 2017 (15.9)那么怎么知道 MSC 的版本信息呢？这个也简单，进入 Python Shell 的时候会有打印信息的。比如像下面这样：根据打印信息，就可以知道 Python 3.4.1 的 MSC 版本信息。原因分析那这个问题的根本原因是什么呢？根本原因应该是安装第三方库的时候，需要编译库的源码，而源码里包含有 C/C++ 的代码。编译 C/C++ 的代码，就需要到对应的编译器，然后就会查找系统安装的编译器，当找不到的时候，就会报 unable to find vcvarsall.bat 这个错误。安装 VS/VC 之后，就安装有 C/C++ 的编译器了，这个错误就不会有了。不同版本的编译器不一定会兼容，所以就需要安装与编译 Python 时候所用的编译器版本吻合的编译器，不然要不是编译不了，要么是编译出的产物无法使用。一般情况下高版本的编译器向下兼容低版本的编译器，但是反过来就无法兼容，所以可以安装相同的或者更高的版本编译器。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>unable to find vcvarsall.bat</tag>
        <tag>pip</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python defaultdict使用]]></title>
    <url>%2F2019%2F07%2F14%2FPython-defaultdict%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本篇内容节选和改编自《Python 进阶》Python除了dict外，还有个defaultdict。与dict不同的是，defaultdict不需要事先检查key是否存在。下面介绍下defaultdict的用法。1234567891011121314151617from collections import defaultdictcolours = ( ('Yasoob', 'Yellow'), ('Ali', 'Blue'), ('Arham', 'Green'), ('Ali', 'Black'), ('Yasoob', 'Red'), ('Ahmed', 'Silver'))favourite_colours = defaultdict(list)for name, colour in colours: favourite_colours[name].append(colour)print(favourite_colours)运行输出:123456# defaultdict(&lt;type 'list'&gt;, &#123;'Arham': ['Green'], 'Yasoob': ['Yellow', 'Red'], 'Ahmed': ['Silver'], 'Ali': ['Blue', 'Black']&#125;)另一个重要的例子是: 当在dict里进行嵌套赋值时，如果key不存在，会触发KeyError异常，使用defaultdict可以解决这个问题。先看一个例子:1234some_dict = &#123;&#125;some_dict['colours']['favourite'] = 'yellow'# 异常输出: KeyError: 'colours'解决方案:1234567import collections# 这行是关键，也很抽象tree = lambda: collections.defaultdict(tree)some_dict = tree()some_dict['colours']['favourite'] = 'yellow'# 运行正常使用 json.dumps打印some_dict:1234import jsonprint(json.dumps(some_dict))# 输出: &#123;"colours": &#123;"favourite": "yellow"&#125;&#125;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>defaultdict</tag>
        <tag>Python 进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好书分享]]></title>
    <url>%2F2019%2F07%2F14%2F%E5%A5%BD%E4%B9%A6%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[记录遇到的好书、好教程，不定期更新。本次更新时间: 2019-07-14 11:10:00编程语言PythonPython 入门教程《Intermediate Python》，有中文译本《Python 进阶》。原版链接: Intermediate Python中文译本: Python 进阶版本管理GitGit教程 - 廖雪峰Learn Git Branching网站性能《构建高性能 Web 站点》Explore Flask]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>好书推荐</tag>
        <tag>学习资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决PyMongo时区问题]]></title>
    <url>%2F2019%2F07%2F14%2F%E8%A7%A3%E5%86%B3PyMongo%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[MongoDB默认是以 UTC 格式存储时间和日期的，跟本地的时间是有时差的，一般保存的时候会将本地时间转为 UTC 时间再保存。那读取的时候也需要每次都手动转为本地时间吗？解决方法其实不需要。MongoClient对象初始化的时候，支持tz_aware参数。当tz_aware为True的时候，读取出来的时间是会自动转为本地时间的，这个特性是由BSON编解码器提供的，tz_aware参数最终会传递到CodecOptions里，供BSON编码解码器在编解码的时候使用。注意事项tz_aware需要跟tzinfo参数搭配使用。当tz_aware为True的时候，需要指定tzinfo。123456import pytzclient = MongoClient(tz_aware=True, tzinfo=pytz.timezone('Asia/Shanghai')# 或者# from flask_pymongo import PyMongo# client = PyMongo(app, tz_aware=True, tzinfo=pytz.timmezone('Asia//Shanghai'))当使用tz_aware自动转换时间的情况下，转换出来的时间对象是带有时区信息的，不能直接跟本地时间进行加减，需要先去掉时区信息。12def remove_timezone(dt: datetime) -&gt; datetime: return dt.replace(tzinfo=None)]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>PyMongo</tag>
        <tag>时区</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 打开 exe 程序]]></title>
    <url>%2F2017%2F11%2F30%2FJava-%E6%89%93%E5%BC%80-exe-%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[在实现 JavaFX 应用自更新的时候，需要在主应用(main.exe)里打开更新应用(update.exe)，一开始想通过 ProcessBuilder 启动一个子进程实现的，但是这种方式打开的应用没有管理员的权限，更新应用需要管理员权限。经过一番查找之后，在 StackOverflow 上发现了另外一种方式可以打开 exe 应用，并且可以通过 UAC 提升为管理员权限。具体方式就是：用 JNA 调用 Windows 的 API，用系统的接口打开 exe 应用。添加 JNA到 JNA 官网下载对应的 jar 文件加到项目 classpath 即可。原文的代码Shell32X.java:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import com.sun.jna.Native;import com.sun.jna.Pointer;import com.sun.jna.Structure;import com.sun.jna.WString;import com.sun.jna.platform.win32.Shell32;import com.sun.jna.platform.win32.WinDef.HINSTANCE;import com.sun.jna.platform.win32.WinDef.HWND;import com.sun.jna.platform.win32.WinNT.HANDLE;import com.sun.jna.platform.win32.WinReg.HKEY;import com.sun.jna.win32.W32APIOptions;public interface Shell32X extends Shell32&#123; Shell32X INSTANCE = (Shell32X)Native.loadLibrary("shell32", Shell32X.class, W32APIOptions.UNICODE_OPTIONS); int SW_HIDE = 0; int SW_MAXIMIZE = 3; int SW_MINIMIZE = 6; int SW_RESTORE = 9; int SW_SHOW = 5; int SW_SHOWDEFAULT = 10; int SW_SHOWMAXIMIZED = 3; int SW_SHOWMINIMIZED = 2; int SW_SHOWMINNOACTIVE = 7; int SW_SHOWNA = 8; int SW_SHOWNOACTIVATE = 4; int SW_SHOWNORMAL = 1; /** File not found. */ int SE_ERR_FNF = 2; /** Path not found. */ int SE_ERR_PNF = 3; /** Access denied. */ int SE_ERR_ACCESSDENIED = 5; /** Out of memory. */ int SE_ERR_OOM = 8; /** DLL not found. */ int SE_ERR_DLLNOTFOUND = 32; /** Cannot share an open file. */ int SE_ERR_SHARE = 26; int SEE_MASK_NOCLOSEPROCESS = 0x00000040; int ShellExecute(int i, String lpVerb, String lpFile, String lpParameters, String lpDirectory, int nShow); boolean ShellExecuteEx(SHELLEXECUTEINFO lpExecInfo); public static class SHELLEXECUTEINFO extends Structure &#123; /* DWORD cbSize; ULONG fMask; HWND hwnd; LPCTSTR lpVerb; LPCTSTR lpFile; LPCTSTR lpParameters; LPCTSTR lpDirectory; int nShow; HINSTANCE hInstApp; LPVOID lpIDList; LPCTSTR lpClass; HKEY hkeyClass; DWORD dwHotKey; union &#123; HANDLE hIcon; HANDLE hMonitor; &#125; DUMMYUNIONNAME; HANDLE hProcess; */ public int cbSize = size(); public int fMask; public HWND hwnd; public WString lpVerb; public WString lpFile; public WString lpParameters; public WString lpDirectory; public int nShow; public HINSTANCE hInstApp; public Pointer lpIDList; public WString lpClass; public HKEY hKeyClass; public int dwHotKey; /* * Actually: * union &#123; * HANDLE hIcon; * HANDLE hMonitor; * &#125; DUMMYUNIONNAME; */ public HANDLE hMonitor; public HANDLE hProcess; protected List getFieldOrder() &#123; return Arrays.asList(new String[] &#123; "cbSize", "fMask", "hwnd", "lpVerb", "lpFile", "lpParameters", "lpDirectory", "nShow", "hInstApp", "lpIDList", "lpClass", "hKeyClass", "dwHotKey", "hMonitor", "hProcess", &#125;); &#125; &#125;&#125;Elevator.java:12345678910111213141516171819202122232425262728293031323334package test;import test.Shell32X.SHELLEXECUTEINFO;import com.sun.jna.WString;import com.sun.jna.platform.win32.Kernel32;import com.sun.jna.platform.win32.Kernel32Util;public class Elevator&#123; public static void main(String... args) &#123; executeAsAdministrator("c:\\windows\\system32\\notepad.exe", ""); &#125; public static void executeAsAdministrator(String command, String args) &#123; Shell32X.SHELLEXECUTEINFO execInfo = new Shell32X.SHELLEXECUTEINFO(); execInfo.lpFile = new WString(command); if (args != null) execInfo.lpParameters = new WString(args); execInfo.nShow = Shell32X.SW_SHOWDEFAULT; execInfo.fMask = Shell32X.SEE_MASK_NOCLOSEPROCESS; execInfo.lpVerb = new WString("runas"); boolean result = Shell32X.INSTANCE.ShellExecuteEx(execInfo); if (!result) &#123; int lastError = Kernel32.INSTANCE.GetLastError(); String errorMessage = Kernel32Util.formatMessageFromLastErrorCode(lastError); throw new RuntimeException("Error performing elevation: " + lastError + ": " + errorMessage + " (apperror=" + execInfo.hInstApp + ")"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JNA</tag>
        <tag>UAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium 滑动验证码处理(二)]]></title>
    <url>%2F2017%2F11%2F27%2FSelenium-%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E5%A4%84%E7%90%86-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[在之前的一篇文章里介绍了利用真实鼠标滑动轨迹来绕过滑动验证码的方法，这种方法有个缺点: 采集的轨迹很难覆盖全部的移动距离，最终的移动距离跟目标距离有一定的误差。那么有没有其他的方法呢?在做动画效果的时候，看着左右不断平移的画面，突然有个想法: 这么顺滑的移动效果能不能用滑验证码呢?有想法那就试试:12345678910111213141516171819202122232425262728293031private void moveWithInterpolator(WebDriver driver, WebElement element, int distance) &#123; // 自定义一个插值器, 先加速后减速 Interpolator interpolator = new Interpolator() &#123; @Override protected double curve(double t) &#123; return Math.cos((t + 1) * Math.PI) / 2F + 0.5F; &#125; &#125;; Actions actions = new Actions(driver); // 按住滑块 actions.moveToElement(element); actions.clickAndHold(element).perform(); IntegerProperty distanceProperty = new SimpleIntegerProperty(); distanceProperty.addListener((ov, oldValue, newValue) -&gt; &#123; // distanceProperty 的值变化时的回调 int offset = newValue.intValue() - oldValue.intValue(); actions.moveByOffset(offset, 0).perform(); &#125;); // 将 distanceProperty 变化到 distance KeyValue keyValue = new KeyValue(distanceProperty, distance, interpolator); KeyFrame keyFrame = new KeyFrame(Duration.millis(250 + distance), e -&gt; &#123; // 动画结束后释放鼠标 actions.release(element).perform(); &#125;, keyValue); Timeline timeline = new Timeline(keyFrame); timeline.play();&#125;经过试验，这种方法的成功率也有80%左右，整个流程简化了不少，免去了采集和还原轨迹的步骤，移动距离能全部覆盖到，并且速度较原来的方法有很大的提升。]]></content>
      <categories>
        <category>Selenium</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Selenium</tag>
        <tag>滑动验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium 滑动验证码处理]]></title>
    <url>%2F2017%2F11%2F16%2FSelenium-%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[简述在使用 Selenium 抓取数据的时候，遇到了滑动验证码，找了下相关资料，发现一篇博客正是想要的，非常感谢原作者。不过经试验，原文的成功率达不到需求，主要原因是模拟鼠标移动的轨迹不够理想。于是针对鼠标轨迹模拟部分进行改进，使成功率达到了 80% 左右，满足了实际使用的需求。模拟验证过程加载验证码页面获取背景图片和缺口图片根据两张图片的差异计算出平移距离模拟鼠标移动，移动滑块到目标位置完成验证其中背景图片和缺口图片需要拼接还原才能得到原图。鼠标移动轨迹优化滑动验证码主要是通过滑动轨迹来区分人和机器，所以模拟移动的轨迹就是关键部分。越接近人类滑动的轨迹，成功率就越高。那么最真实的轨迹就是采集真实用户的鼠标轨迹，然后还原出来。轨迹采集轨迹采集使用 GhostMouse 这款软件，可以将采集的轨迹保存成脚本文件，文件的格式大概是这样子的:123456789101112&#123;Delay 0.45&#125;&#123;LMouse down (858,563)&#125;&#123;Delay 0.25&#125;&#123;Move (858,563)&#125;&#123;Delay 0.04&#125;&#123;Move (858,563)&#125;...&#123;Move (1001,559)&#125;&#123;Delay 0.66&#125;&#123;LMouse up (1002,559)&#125;轨迹转化有了真实的轨迹之后，需要抽象转化为 Java 对象，方便还原。轨迹主要的动作有四个：按下、释放、移动、延时，移动动作的绝对坐标转换为相对上个位置的偏移坐标，使用 MouseTrack 表示一次动作。MouseTrack.java:123456789101112131415161718192021/** * 鼠标轨迹 * @author cengt */public class MouseTrack &#123; public enum OP &#123; DELAY, MOVE, MOUSE_UP, MOUSE_DOWN; &#125; /** 动作 */ private OP mOp; /** 延时时间(ms) */ private int mDelay; /** 移动偏移量 */ private Point mPoint; ... &#125;读取保存的轨迹文件:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class MouseTrackManager &#123; ... /** 读取 GhostMouse 记录的鼠标轨迹 */ public void readTracks(String trackPath) &#123; File dir = new File(trackPath); File[] files = dir.listFiles(); if (files == null || files.length == 0) &#123; logger.error("no mouse track files: &#123;&#125;", trackPath); return; &#125; for (File trackFile : dir.listFiles()) &#123; try &#123; List&lt;String&gt; lines = FileUtils.readLines(trackFile, "UTF-8"); int startX = 0, endX = 0; int startY = 0; int lastX = 0, lastY = 0; List&lt;MouseTrack&gt; tracks = new ArrayList&lt;&gt;(); for (String line : lines) &#123; int delay = 0: Point point = null; OP op = null; if (line.contains("Delay")) &#123; String delayString = line.replaceAll("[^0-9.]*", ""); delay = (int) (Float.parseFloat(delayString) * 1000); op = OP.DELAY; &#125; else if (line.contains("LMouse down")) &#123; point = getPoint(line); startX = point.x; startY = point.y; lastX = startX; lastY = startY; op = OP.MOUSE_DOWN; &#125; else if (line.contains("LMouse up")) &#123; point = getPoint(line); endX = point.x; op = OP.MOUSE_UP; &#125; else if (line.contains("Move")) &#123; Point p = getPoint(line); point = new Point(p.x - lastX, p.y - lastY); lastX = p.x; lastY = p.y; op = OP.MOVE; &#125; if (op == null) &#123; logger.error("unsupported op: &#123;&#125;", line); &#125; else &#123; tracks.add(new MouseTrack(op, delay, point)); &#125; &#125; // 以移动的偏移量作为 Key 保存 int offset = endX - startX; mMouseTracks.put(offset, tracks); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; logger.info("read tracks: &#123;&#125;", mMouseTracks.size()); &#125; private Point getPoint(String line) &#123; String[] axis = line.replaceAll("[^0-9,]*", "").split(","); int x = Integer.parseInt(axis[0]); int y = Integer.parseInt(axis[1]); return new Point(x, y); &#125; ... &#125;轨迹还原有了轨迹的相关数据之后，就可以对轨迹进行还原了。获取轨迹根据目标位移距离，选择一个最接近的轨迹来还原。12345678910111213141516171819202122232425/** * 选取轨迹 * @param xDis 目标位移距离 * @return 最接近目标距离的轨迹 */private List&lt;MouseTrack&gt; getMouseTrack(int xDis) &#123; Map&lt;Integer, List&lt;MouseTrack&gt;&gt; tracks = mTrackManager.getMouseTracks(); List&lt;MouseTrack&gt; result = tracks.get(xDis); if (result != null) &#123; return result; &#125; int offset = 0; int min = Integer.MAX_VALUE; for (int k : tracks.keySet()) &#123; int t = Math.abs(xDis - k); if (t &lt; min) &#123; offset = k; min = t; &#125; &#125; result = mTrackManager.getMouseTracks().get(offset); return result;&#125;执行轨迹动作一个轨迹是一系列动作的列表，依次执行每个动作就可以还原出来了。1234567891011121314151617181920212223242526272829303132333435363738private void moveWithMouseTrack(WebDriver driver, WebElement element, int distance) throws InterruptedException &#123; List&lt;MouseTrack&gt; tracks = getMouseTrack(distance); if (tracks == null) &#123; logger.error("no match track: &#123;&#125;", distance); return; &#125; Actions actions = new Actions(driver); actions.moveToElement(element); for (MouseTrack track : tracks) &#123; switch (track.getOp()) &#123; case DELAY: int delay = track.getDelay(); // 忽略时间太短的延时动作 if (delay &gt;= 60) &#123; delay -= 160; &#125; if (delay &gt; 60) &#123; Thread.sleep(delay); &#125; break; case MOUSE_DOWN: actions.clickAndHold(element).perform(); break; case MOUSE_UP: actions.release(element).perform(); break; case MOVE: Point point = track.getPoint(); actions.moveByOffset(point.x, point.y).perform(); break; &#125; &#125;&#125;有个地方需要注意一下，由于延时这个动作使用 Thread.sleep() 实现，但是这个方法是有误差的，而且执行次数较多，累计起来的误差就会较大，导致移动速度比原来的慢。所以对于延时这个动作，忽略掉延时时间太短，以加快整个动作的流畅性。最终效果图无图无真相，上图！源码源码，是没有的，自己写吧。不要像我这样那么懒。]]></content>
      <categories>
        <category>Selenium</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Selenium</tag>
        <tag>滑动验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 以太网IP设置]]></title>
    <url>%2F2016%2F11%2F27%2FAndroid-%E4%BB%A5%E5%A4%AA%E7%BD%91IP%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[简单记录下 Android 5.1 系统以太网的 IP 设置方法。(到5.1的版本为止，与以太网相关的 API 都是隐藏起来的，有@hide注解，需要通过反射调用，或者引用没有@hide注解的 android.jar 文件，可以使用编译源码生成的 out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar)EthernetManager 获取EthernetManager 使用单例模式，可以通过 Context 的 getSystemService() 方法获取:123private EthernetManager getEthernetManager(Context context) &#123; return (EthernetManager) context.getSystemService(Context.ETHERNET_SERVICE);&#125;Context.ETHERNET_SERVICE 也是有@hide注解的，可以定义一个常量替代:1private static final String ETHERNET_SERVICE = "ethernet";DHCP以太网的 IP 设置通过 IpConfiguration 来配置，其中的 ipAssignment 变量决定 IP 的分配方式，值可以为 IpAssignment.DHCP、 IpAssignment.STATIC、 IpAssignment.UNASSIGNED，分别为动态 IP、静态 IP、未指定。IpConfiguration 通过 EthernetManager 的 getConfiguration() 获取，通过 setConfiguration() 使配置生效。设置以太网使用 DHCP 方式获取 IP 的代码如下:1234567891011121314/** 设置网线使用DHCP方式获取IP */public void enableEthernetDHCP(Context context) &#123; Logger.d("enableEthernetDHCP"); if (context == null) &#123; Logger.e("invaild argument"); return; &#125; EthernetManager em = getEthernetManager(context); IpConfiguration configuration = em.getConfiguration(); configuration.setIpAssignment(IpConfiguration.IpAssignment.DHCP); em.setConfiguration(configuration);&#125;静态 IP静态 IP 方式则稍微复杂一点，静态 IP 方式需要指定 IP 地址、子网掩码、网关地址、DNS 服务器地址，这几项信息不对会造成设置失败。这些信息的通过 StaticIpConfiguration 设置，StaticIpConfiguration 通过 IpConfiguration 获取:1StaticIpConfiguration staticIpConfiguration = configuration.getStaticIpConfiguration();首先修改 IpConfiguration 的 ipAssignment 值为 IpAssignment.STATIC，然后设置静态 IP 的信息，最后 setConfiguration() 使配置生效，代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * @author cengt 2016/11/1 10:01 * @version v1.0 */public class XTHost &#123; /** IP */ private String ip; /** 网关 */ private String gateway; /** 子网掩码 */ private String netmask; ... &#125; /** 设置网线使用静态方式获取IP */ public void enableEthernetStaticIP(Context context, XTHost host) &#123; Logger.d("enableEthernetStaticIP: host = " + host); if (context == null || host == null) &#123; Logger.e("invalid argument"); return; &#125; EthernetManager em = getEthernetManager(context); IpConfiguration configuration = em.getConfiguration(); configuration.setIpAssignment(IpConfiguration.IpAssignment.STATIC); StaticIpConfiguration staticIpConfiguration = configuration.getStaticIpConfiguration(); staticIpConfiguration.gateway = NetworkUtils.numericToInetAddress(host.getGateway()); InetAddress ipAddress = NetworkUtils.numericToInetAddress(host.getIp()); int prefixLength = netmask2PrefixLength(host.getNetmask()); staticIpConfiguration.ipAddress = createLinkAddress(ipAddress, prefixLength); // 使用网关作为DNS地址 staticIpConfiguration.dnsServers.add(NetworkUtils.numericToInetAddress(host.getGateway())); configuration.setStaticIpConfiguration(staticIpConfiguration); em.setConfiguration(configuration); &#125; /** 掩码字符串转为掩码长度 */ private int netmask2PrefixLength(String netmask) &#123; int sum = 0; String[] values = netmask.split("\\."); for (String s : values) &#123; sum += NetworkUtils.netmaskIntToPrefixLength(Integer.parseInt(s)); &#125; return sum; &#125; private LinkAddress createLinkAddress(InetAddress ipAddress, int prefixLength) &#123; try &#123; Class&lt;?&gt; clazz = Class.forName("android.net.LinkAddress"); Class&lt;?&gt;[] parTypes = new Class&lt;?&gt;[2]; parTypes[0] = InetAddress.class; parTypes[1] = int.class; Constructor&lt;?&gt; constructor = clazz.getConstructor(parTypes); Object[] pars = new Object[2]; pars[0] = ipAddress; pars[1] = prefixLength; return (LinkAddress) constructor.newInstance(pars); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;其中子网掩码是通过二进制形式1的位数设置的，比如: 255.255.255.0 则设置为24，LinkAddress 类通过反射方式获取实例。判断以太网线是否插入可以通过 /sys/class/net/eth0/operstate 这个文件判断以太网是否插入，插入网线的情况下这个文件的值为 up，未插入情况下为 down，代码如下:123456789101112131415161718192021222324/** 网线是否插入 */@SuppressWarnings("ResultOfMethodCallIgnored")public boolean isEthernetPlugin() &#123; FileInputStream fin = null; try &#123; fin = new FileInputStream(ETHERNET_OPERSTATE_PATH); byte[] buff = new byte[fin.available()]; fin.read(buff); String str = new String(buff, StandardCharsets.UTF_8); return "UP".equalsIgnoreCase(str.trim()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (fin != null) &#123; try &#123; fin.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return false;&#125;获取以太网的连接信息通过 ConnectivityManager 的 getLinkProperties() 方法获取，代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** 获取网线连接信息 */public XTHost getEthernetInfo(Context context) &#123; ConnectivityManager cm = getConnectivityManager(context); Network ethernetNetwork = getEthernetNetwork(context); if (ethernetNetwork != null) &#123; LinkProperties activedLinkProperties = cm.getLinkProperties(ethernetNetwork); if (activedLinkProperties != null) &#123; XTHost host = new XTHost(); // 查找IP和子网掩码 List&lt;LinkAddress&gt; addresses = activedLinkProperties.getLinkAddresses(); if (addresses.size() &gt; 0) &#123; LinkAddress addr = addresses.get(0); host.setIp(addr.getAddress().getHostAddress()); host.setNetmask(prefixLength2Netmask(addr.getPrefixLength())); &#125; else &#123; Logger.e("linkaddresses size &lt;= 0"); &#125; // 查找默认的网关 boolean foundDefaultRoute = false; List&lt;RouteInfo&gt; routes = activedLinkProperties.getRoutes(); for (RouteInfo r : routes) &#123; if (r.isDefaultRoute()) &#123; host.setGateway(r.getGateway().getHostAddress()); foundDefaultRoute = true; break; &#125; &#125; // 没找到默认的网关则使用第一个 if (!foundDefaultRoute &amp;&amp; routes.size() &gt; 0) &#123; host.setGateway(routes.get(0).getGateway().getHostAddress()); &#125; return host; &#125; &#125; else &#123; Logger.e("error get ethernet network"); &#125; return null;&#125;private Network getEthernetNetwork(Context context) &#123; ConnectivityManager cm = getConnectivityManager(context); for (Network network : cm.getAllNetworks()) &#123; NetworkInfo info = cm.getNetworkInfo(network); if (info != null &amp;&amp; info.getType() == ConnectivityManager.TYPE_ETHERNET) &#123; return network; &#125; &#125; return null;&#125;完整源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242package com.xingtel.xtalk.manager;import android.content.Context;import android.net.ConnectivityManager;import android.net.EthernetManager;import android.net.IpConfiguration;import android.net.LinkAddress;import android.net.LinkProperties;import android.net.Network;import android.net.NetworkInfo;import android.net.NetworkUtils;import android.net.RouteInfo;import android.net.StaticIpConfiguration;import com.orhanobut.logger.Logger;import com.xingtel.xtalk.model.XTHost;import java.io.FileInputStream;import java.io.IOException;import java.lang.reflect.Constructor;import java.net.InetAddress;import java.nio.charset.StandardCharsets;import java.util.List;import java.util.Locale;import static android.content.Context.CONNECTIVITY_SERVICE;/** * @author cengt 2016/11/14 12:18 * @version v1.0 */public class XTNetWorkManager &#123; private static final String ETHERNET_SERVICE = "ethernet"; private static final String ETHERNET_OPERSTATE_PATH = "/sys/class/net/eth0/operstate"; public static XTNetWorkManager getInstance() &#123; return SingletonHolder.INSTANCE; &#125; /** 网络是否正常(包括所有网络) */ public boolean isNetWorkOn(Context context) &#123; if (context != null) &#123; ConnectivityManager cm = getConnectivityManager(context); NetworkInfo activedNetworkInfo = cm.getActiveNetworkInfo(); return (activedNetworkInfo != null &amp;&amp; activedNetworkInfo.isConnected()); &#125; return false; &#125; /** 网线是否插入 */ @SuppressWarnings("ResultOfMethodCallIgnored") public boolean isEthernetPlugin() &#123; FileInputStream fin = null; try &#123; fin = new FileInputStream(ETHERNET_OPERSTATE_PATH); byte[] buff = new byte[fin.available()]; fin.read(buff); String str = new String(buff, StandardCharsets.UTF_8); return "UP".equalsIgnoreCase(str.trim()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (fin != null) &#123; try &#123; fin.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return false; &#125; public boolean isEthernetConnected(Context context) &#123; Network network = getEthernetNetwork(context); if (network != null) &#123; NetworkInfo info = getConnectivityManager(context).getNetworkInfo(network); return info != null &amp;&amp; info.isConnected(); &#125; return false; &#125; /** 网线是否使用DHCP方式获取IP */ public boolean isEthernetUseDHCP(Context context) &#123; if (context == null) &#123; Logger.e("invaild argument"); return false; &#125; EthernetManager em = getEthernetManager(context); return em != null &amp;&amp; em.getConfiguration().getIpAssignment() == IpConfiguration.IpAssignment.DHCP; &#125; /** 设置网线使用DHCP方式获取IP */ public void enableEthernetDHCP(Context context) &#123; Logger.d("enableEthernetDHCP"); if (context == null) &#123; Logger.e("invaild argument"); return; &#125; EthernetManager em = getEthernetManager(context); IpConfiguration configuration = em.getConfiguration(); configuration.setIpAssignment(IpConfiguration.IpAssignment.DHCP); em.setConfiguration(configuration); &#125; /** 设置网线使用静态方式获取IP */ public void enableEthernetStaticIP(Context context, XTHost host) &#123; Logger.d("enableEthernetStaticIP: host = " + host); if (context == null || host == null) &#123; Logger.e("invaild argument"); return; &#125; EthernetManager em = getEthernetManager(context); IpConfiguration configuration = em.getConfiguration(); configuration.setIpAssignment(IpConfiguration.IpAssignment.STATIC); StaticIpConfiguration staticIpConfiguration = configuration.getStaticIpConfiguration(); staticIpConfiguration.gateway = NetworkUtils.numericToInetAddress(host.getGateway()); InetAddress ipAddress = NetworkUtils.numericToInetAddress(host.getIp()); int prefixLength = netmask2PrefixLength(host.getNetmask()); staticIpConfiguration.ipAddress = createLinkAddress(ipAddress, prefixLength); // 使用网关作为DNS地址 staticIpConfiguration.dnsServers.add(NetworkUtils.numericToInetAddress(host.getGateway())); configuration.setStaticIpConfiguration(staticIpConfiguration); em.setConfiguration(configuration); &#125; /** 获取网线连接信息 */ public XTHost getEthernetInfo(Context context) &#123; ConnectivityManager cm = getConnectivityManager(context); Network ethernetNetwork = getEthernetNetwork(context); if (ethernetNetwork != null) &#123; LinkProperties activedLinkProperties = cm.getLinkProperties(ethernetNetwork); if (activedLinkProperties != null) &#123; XTHost host = new XTHost(); // 查找IP和子网掩码 List&lt;LinkAddress&gt; addresses = activedLinkProperties.getLinkAddresses(); if (addresses.size() &gt; 0) &#123; LinkAddress addr = addresses.get(0); host.setIp(addr.getAddress().getHostAddress()); host.setNetmask(prefixLength2Netmask(addr.getPrefixLength())); &#125; else &#123; Logger.e("linkaddresses size &lt;= 0"); &#125; // 查找默认的网关 boolean foundDefaultRoute = false; List&lt;RouteInfo&gt; routes = activedLinkProperties.getRoutes(); for (RouteInfo r : routes) &#123; if (r.isDefaultRoute()) &#123; host.setGateway(r.getGateway().getHostAddress()); foundDefaultRoute = true; break; &#125; &#125; // 没找到默认的网关则使用第一个 if (!foundDefaultRoute &amp;&amp; routes.size() &gt; 0) &#123; host.setGateway(routes.get(0).getGateway().getHostAddress()); &#125; return host; &#125; &#125; else &#123; Logger.e("error get ethernet network"); &#125; return null; &#125; private XTNetWorkManager() &#123;&#125; @SuppressWarnings("WrongConstant") private EthernetManager getEthernetManager(Context context) &#123; return (EthernetManager) context.getSystemService(ETHERNET_SERVICE); &#125; private ConnectivityManager getConnectivityManager(Context context) &#123; return (ConnectivityManager) context.getSystemService(CONNECTIVITY_SERVICE); &#125; private Network getEthernetNetwork(Context context) &#123; ConnectivityManager cm = getConnectivityManager(context); for (Network network : cm.getAllNetworks()) &#123; NetworkInfo info = cm.getNetworkInfo(network); if (info != null &amp;&amp; info.getType() == ConnectivityManager.TYPE_ETHERNET) &#123; return network; &#125; &#125; return null; &#125; /** 掩码长度转为掩码字符串 */ private String prefixLength2Netmask(int prefixLength) &#123; int value = 0xFFFFFFFF &lt;&lt; (32 - prefixLength); int a = 0xFF &amp; (value &gt;&gt; 24); int b = 0xFF &amp; (value &gt;&gt; 16); int c = 0xFF &amp; (value &gt;&gt; 8); int d = 0xFF &amp; value; return String.format(Locale.getDefault(), "%d.%d.%d.%d", a, b, c, d); &#125; /** 掩码字符串转为掩码长度 */ private int netmask2PrefixLength(String netmask) &#123; int sum = 0; String[] values = netmask.split("\\."); for (String s : values) &#123; sum += NetworkUtils.netmaskIntToPrefixLength(Integer.parseInt(s)); &#125; return sum; &#125; private LinkAddress createLinkAddress(InetAddress ipAddress, int prefixLength) &#123; try &#123; Class&lt;?&gt; clazz = Class.forName("android.net.LinkAddress"); Class&lt;?&gt;[] parTypes = new Class&lt;?&gt;[2]; parTypes[0] = InetAddress.class; parTypes[1] = int.class; Constructor&lt;?&gt; constructor = clazz.getConstructor(parTypes); Object[] pars = new Object[2]; pars[0] = ipAddress; pars[1] = prefixLength; return (LinkAddress) constructor.newInstance(pars); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; private static class SingletonHolder &#123; private static final XTNetWorkManager INSTANCE = new XTNetWorkManager(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>以太网</tag>
        <tag>Ethernet</tag>
        <tag>DHCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android部分第三方库使用总结]]></title>
    <url>%2F2016%2F10%2F29%2FAndroid%E9%83%A8%E5%88%86%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[近段时间使用了一些 Android 平台的第三方库，发现用起来很爽，可以大大提升开发效率，特此记录下。主要使用了以下几个库:ButterknifeRetrofitGsonFrescoLoggerButterknife 是一个 View 的依赖注入框架，目的是实现 View 查找、事件监听绑定，可以减少代码量，让代码看起来更清晰。Retrofit 是一个网络请求框架，封装了访问网络方面的细节，可以让开发者更加专注于业务方面。Fresco 则是一个图片加载框架，用于加载不同类型的图片，包括本地、网络等来源的，提供了图片处理方面的解决方案。Logger 则是关于 Log 方面的，是对 Android 自带 log 的增强，更加方便易用。Gson 是用来 json 格式数据的，可以和 Retrofit 搭配来用，直接将服务端返回的 json 数据转换为 Java 对象。为了熟悉这些库的使用，写了个练手的小应用，通过豆瓣开放平台的 API，实现豆瓣读书的搜索功能，主要的需求为向豆瓣的服务器发起图书搜索请求，然后将返回的数据解析显示，很简单的一个需求，其中涉及到了网络和图片加载两大方面的内容。这个需求是参考了网上一位叫阳春面博主的，在这里表示感谢，他的博客写的很好，可以去看看。应用效果如下:Butterknife简介相信从事 Android 应用开发的同学都写过不少的 findViewById() 代码，界面复杂点的就会有一堆 findViewById() 出现，与之类似的还有 setOnClickListener() 等，Butterknife 就是为了减少这些重复而没有太多意义的代码的，使代码更简洁，举个栗子对比下。使用前:12345678910protected Toolbar mToolbar;protected DrawerLayout mDrawer;protected MainNavigationView mNavigationView;private void initView() &#123; mToolbar = (Toolbar) findViewById(R.id.toolbar); mDrawer = (DrawerLayout) findViewById(R.id.drawer_layout); mNavigationView = (MainNavigationView) findViewById(R.id.nav_view); mSearchView = (DBBookSearchView) findViewById(R.id.search_view);&#125;使用后:123456789101112131415@BindView(R.id.toolbar)protected Toolbar mToolbar;@BindView(R.id.drawer_layout)protected DrawerLayout mDrawer;@BindView(R.id.nav_view)protected MainNavigationView mNavigationView;@BindView(R.id.search_view)protected DBBookSearchView mSearchView;private void initView() &#123; ButterKnife.bind(this);&#125;直接在定义的时候就绑定了，貌似代码行数并没有少啊，反而还多了一些，但是不觉得看起来更清晰么？其实 Butterknife 还可以绑定一些常用的事件，比如 onClick()、onItemClick()、OnCheckedChanged()等，举个栗子:1234@OnClick(&#123;R.id.toolbar, R.id.drawer_layout, R.id.search_view&#125;)public void onClick(View v) &#123; // TODO&#125;@OnClick 注解作用就等同于 setOnClickListener()，还有其他的注解，作用类似，更多用法可以参考 Butterknife官方文档。有一个需要注意的地方是变量或类不能是 private 修饰的。集成到项目添加 Butterknife 到项目需要两个步骤:在项目级别的 build.grade 添加如下内容:12345678buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' &#125;&#125;在应用级别的 build.gradle 添加如下内容:12345678910apply plugin: 'android-apt'android &#123; ...&#125;dependencies &#123; compile 'com.jakewharton:butterknife:8.4.0' apt 'com.jakewharton:butterknife-compiler:8.4.0'&#125;Retrofit简介在开发 Android 网络方面的时候，直接使用原生的 API 个人感觉是比较痛苦的，需要涉及的东西比较多，各方面都需要考虑周到，Retrofit 则可以解决这些痛苦，原来网络编程也可以这么爽。Retrofit 是在 OkHttp 上进一步的封装，还可以将返回结果直接解析转换出来，支持常见的 json、xml 等数据格式，比如服务器返回的是 json 数据，跟 Gson 搭配使用简直不能更方便了。使用套路比如下面这样的 json 数据，是搜索豆瓣读书返回的结果:1https://api.douban.com/v2/book/search?q=穆斯林的葬礼大概有以下这么几个步骤将上面的数据解析成 Java 对象:新建一个类，里面的字段跟搜索结果对应1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 豆瓣图书搜索结果的响应 * @author cengt 2016/10/22 12:44 * @version v1.0 */public class QueryDBBookRespone &#123; /** 请求的搜索结果数量 */ @SerializedName("count") private int mCount; /** 搜索结果起始位置 */ @SerializedName("start") private int mStart; /** 返回的搜索结果数量 */ @SerializedName("total") private int mTotal; /** 搜索的图书列表 */ @SerializedName("books") private List&lt;DBBook&gt; mBooks; public int getCount() &#123; return mCount; &#125; public void setCount(int count) &#123; mCount = count; &#125; public int getStart() &#123; return mStart; &#125; public void setStart(int start) &#123; mStart = start; &#125; public int getTotal() &#123; return mTotal; &#125; public void setTotal(int total) &#123; mTotal = total; &#125; public List&lt;DBBook&gt; getBooks() &#123; return mBooks; &#125; public void setBooks(List&lt;DBBook&gt; books) &#123; mBooks = books; &#125; @Override public String toString() &#123; return "QueryDBBookRespone&#123;" + "mCount=" + mCount + ", mStart=" + mStart + ", mTotal=" + mTotal + ", mBooks=" + mBooks + '&#125;'; &#125;&#125;@SerializedName() 注解是 Gson 这个库的，表明序列化的时候字段使用的名称，这个名称需要跟 json 数据里面的 key 对应。接下来定义一个 interface1234567891011121314/** * 豆瓣读书API * @author cengt 2016/10/22 11:20 * @version v1.0 */public interface DBBookService &#123; /** * 通过关键字搜索图书 * @param keyword 想要搜索的关键字 */ @GET("book/search") Call&lt;QueryDBBookRespone&gt; searchBooksByKeyword(@Query("q") String keyword);&#125;@GET() 表明这个请求是 Get 方式的，类似的还是 @POST()、@PUT()、@DELETE() 等，里面的值为 URL 的路径，这个路径是相对的，相对于 BaseURL 的，等下就会看到了。@Query() 指明 URl 里面的参数 。如果这里不明白的建议看看这两篇博客: 你应该知道的HTTP基础知识，你真的会用Retrofit2吗?Retrofit2完全教程，感谢博主。最后就是发起请求了123456789101112131415161718192021222324/** ** 搜索图书(默认搜索20条记录) * @param query 搜索的关键字 */public void search(String query) &#123; Logger.d("query = " + query); Retrofit retrofit = RetrofitManager.getIntance().createDBBookRetrofit(); DBBookService bookService = retrofit.create(DBBookService.class); bookService.searchBooksByKeyword(query).enqueue(new Callback&lt;QueryDBBookRespone&gt;() &#123; @Override public void onResponse(Call&lt;QueryDBBookRespone&gt; call, Response&lt;QueryDBBookRespone&gt; response) &#123; Logger.d("query book done"); onSearchRespone(response); &#125; @Override public void onFailure(Call&lt;QueryDBBookRespone&gt; call, Throwable t) &#123; String msg = t.getLocalizedMessage(); Logger.e(t, "query book error " + msg); onSearchFailure(msg); &#125; &#125;);&#125;12345678910111213141516171819public class RetrofitManager &#123; ... /** 豆瓣读书API的基础路径 */ public static final String BASE_URL_DOUBAN_BOOK = "https://api.douban.com/v2/"; public Retrofit createRetrofit(String baseUrl) &#123; if (baseUrl == null) &#123; return null; &#125; return new Retrofit.Builder() .baseUrl(baseUrl) .addConverterFactory(GsonConverterFactory.create()) .build(); &#125; ...&#125;新建 Retrofit 对象时需要传入一个 baseUrl 参数，这个参数跟上面的路径组成完整的 URl，addConverterFactory() 表示使用 Gson 解析返回来的数据，最后通过 response 对象就可以直接拿到转换好的 Java 对象了。1List&lt;DBBook&gt; books = respone.body().getBooks();使用 Retrofit 基本上只需要关心业务方面的东西了，其中的实现细节根本不用再理会，大大简化了网络方面的开发。集成到项目添加下面内容到应用级别的 build.gradle:12compile 'com.squareup.retrofit2:retrofit:2.1.0'compile 'com.squareup.retrofit2:converter-gson:2.1.0'更多的使用方面参考 Retrofit官方文档，国内也有很多这方面的优秀博客。GsonGson 用来解析 json 数据的，这里主要跟 Retrofit 配合使用，就不过多介绍了。你真的会用Gson吗?Gson使用指南 这里有写的很好的博客，再次感谢博主。FrescoFresco 是一个图片加载库，有了 Fresco，妈妈再也不用担心图片过大出现 OOM 了，也不需要自己管理缓存方面的问题了，不管是本地还是网络的图片，一切都是那么的方便，生活是如此的美好。Fresco 缺点方面就是体积比较大，会让应用的大小增加，如果在意应用大小的，可以考虑其他的图片加载库，比如: Glide。Fresco 用法方面比较简单，使用 SimpleDraweeView 代替 ImageView 就差不多了，大部分需求应该都可以满足了。关于 Fresco 有一点是要特别要提一下的，这货有官方的中文版文档！！！太有良心了！英语没过四级的同学不用瑟瑟发抖了，而且 Fresco官方文档 也写的很好。这里简单记录下用法。基本用法初始化 Fresco，只需一次即可，在 Application 做这件事再适合不过了。1234567public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); Fresco.initialize(this); &#125;&#125;添加 SimpleDraweeView12345&lt;com.facebook.drawee.view.SimpleDraweeView android:id="@+id/db_book_detail_cover" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;需要注意的是 SimpleDraweeView 不支持 wrap_content，必须指定大小或使用 match_parent加载图片1draweeView.setImageURI(imgUrl);集成到项目在应用级别下的 build.gradle 加入如下内容:1compile 'com.facebook.fresco:fresco:0.12.0'更多的用法参考 Fresco官方文档。推荐博文Fresco之强大之余的痛楚Logger简介Logger 是一个 Log 库，功能比 Android 自带的 Log 要强大，用过之后再也不想用回原来的 Log 了，支持输出线程、类、函数等信息，漂亮的 json 数据格式，直接跳转到源码行数等功能，使用方法和 Log 类似，更多详情见 Logger。附上几张官方的图片: 集成到项目在应用级别下的 build.gradle 加入如下内容:1compile 'com.orhanobut:logger:1.15'源码源码在这里，欢迎 start 或 fork。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Butterknife</tag>
        <tag>Retrofit</tag>
        <tag>Fresco</tag>
        <tag>Logger</tag>
        <tag>Gson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人的Vim配置]]></title>
    <url>%2F2016%2F09%2F03%2F%E4%B8%AA%E4%BA%BA%E7%9A%84Vim%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[记录下自己的 Vim 配置文件，避免每次都要去网上搜索资料配置，以后需要的时候直接复制下来即可。配置文件(~/.vimrc)的内容如下:123456789101112131415161718192021syntax onset cursorlineset rulerset shiftwidth=4set softtabstop=4set tabstop=4set expandtabset nobackupset autochdirfiletype plugin indent onset incsearchset hlsearchset showmatchset magicset smartindentset fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936set termencoding=utf-8set encoding=utf-8set ignorecaseset smartcasehi Comment ctermfg=blue]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager 滑动冲突分析与解决]]></title>
    <url>%2F2016%2F08%2F17%2FViewPager-%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[前言ViewPager 的滑动的效果比较不错，常与 Fragment 搭配实现选项卡页面，然而有时候会出现滑动冲突的情况，具体表现为有时候滑不动，下面就最近遇到的情况分析下其中的原因。问题描述在一个 ViewPager 里面有4个 Fragment，第二个 Fragment 里面有一些 TextView 组件，如下图:结果发现在这些 TextView 之间空白的地方可以水平滑动页面，但是在 TextView 上面就无法滑动了。原因分析发现这个问题的时候一脸懵逼，死活想不通是哪里的原因。于是网上搜索一番，有个说法是去掉 TextView 的 android:singleLine=&quot;true&quot; 属性即可，一开始我是不信的，这个属性跟滑动无效似乎没有半毛钱的关系，持着怀疑的态度试了下，问题居然解决了！现在更是想不通了，顺着搜索结果来到了 Stackoverflow 上找原因，有如下这段话:if the view can scroll horizontally, it intercepts the horizontal motion event and ViewPager is not able to process it anymore.Since API Level 14 TextViews have android:scrollHorizontally property (and setHorizontallyScrolling(boolean) method), which, if set to true, causes the TextView to intercept horizontal scroll motion events.You may set it to false either in XML or right in the code, but watch out: android:singleLine property forces android:scrollHorizontally to be set to true! Very tricky point! But fortunately, you usually able to safely replace single line property with android:maxLines=”1” and necessary ellipsize value.看到这里终于知道了为什么。上面这段话的大概意思是如果 ViewPager 里面的组件可以水平滚动，它们将拦截水平滚动的事件，致使 ViewPager 无法接收到水平滚动事件，出现滑动无效的情况。从 API 14 开始，TextView 增加了水平滚动的属性 android:scrollHorizontally 和 setHorizontallyScrolling(boolean) 方法，当该属性为 true 的情况下，TextView 就会拦截水平滚动事件。但是有个恶心的地方，当设置了 android:singleLine=&quot;true&quot; 的时候，android:scrollHorizontally 也将自动变成 true！万幸的是，可以使用 android:maxLines=&quot;1&quot; 等效替代 android:singleLine=&quot;true&quot;。根据上面的结论，总结下 ViewPager 滑动冲突的解决思路。Android 系统触摸事件的处理流程大概是这样的，系统收到触摸事件之后，从点击的组件开始，一层层往最外层的组件进行分发处理，一旦有组件处理消耗了该事件，则结束。如果出现了触摸事件没有预期出现响应的时候，就该考虑下是否是里面的组件拦截了事件。好记性不如烂笔头，随手记录下，以防忘记。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewPager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android BaseAdapter 的抽象与封装]]></title>
    <url>%2F2016%2F08%2F04%2FAndroid-BaseAdapter-%E7%9A%84%E6%8A%BD%E8%B1%A1%E4%B8%8E%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[ListView 是个常用的组件，常用于展示列表数据。使用的时候通常会搭配一个 BaseAdapter 来进行数据的绑定，写多了之后发现，这些 BaseAdapter 都有一些重复或类似的代码，为了让 BaseAdapter 更纯粹，只专注于业务逻辑，所以对 BaseAdapter 进行进一步的抽象。对于 BaseAdapter，通常需要关注的是 getView() 方法，在这个方法里面进行数据跟 UI 的绑定，其他的方法如 getCount()、getItem()、getItemId() 等都是固定的写法，这些方法可以封装起来。getView() 一般使用一个 ViewHolder 来重复利用 UI 组件进行性能优化，不然的话 ListView 随着数据的增大性能会急速下降，会卡成幻灯片一样，所以 getView() 里面的步骤也是类似的，区别的地方在于绑定数据和 UI 响应的部分不一样，所以可以只把绑定数据和 UI 响应部分抽象出来。整体框架先把 getCount()、getItem()、getItemId() 这几个固定的方法封装起来，搭建一个整体的框架，getView() 先留空，下一步再处理。123456789101112131415161718192021222324252627282930313233/** * 通用的 Adapter * Created by cengt on 8/4/16 10:03. */public abstract class CommonAdapter&lt;T&gt; extends BaseAdapter &#123; protected Context mContext; protected List&lt;T&gt; mList; public CommonAdapter(Context context, List&lt;T&gt; list) &#123; mContext = context; mList = list; &#125; @Override public int getCount() &#123; return mList.size(); &#125; @Override public T getItem(int position) &#123; return mList.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; return null; &#125;&#125;封装 GetView()getView() 通常的写法如下:1234567891011121314151617181920212223242526@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder; if (convertView == null) &#123; // UI 布局文件绑定 convertView = LayoutInflater.from(mContext).inflate(R.layout.list_item_apps, parent, false); // 创建一个 ViewHolder 对象，并初始化 UI 组件 holder = new ViewHolder(); holder.appName = (TextView) convertView.findViewById(R.id.app_name); holder.appIcon = (ImageView) convertView.findViewById(R.id.app_icon); // 将 ViewHolder 对象缓存起来，用于下次重复使用 convertView.setTag(holder); &#125; else &#123; // 使用缓存的 ViewHolder 对象，ViewHolder 对象保存了 UI 组件的引用，避免每次都创建新的 UI 组件，可以大幅提高性能 holder = (ViewHolder) convertView.getTag(); &#125; // UI 组件的更新 ResolveInfo info = (ResolveInfo) getItem(position); holder.appName.setText(info.loadLabel(mPackageManager)); holder.appIcon.setImageDrawable(info.loadIcon(mPackageManager)); return convertView;&#125;需要把整个步骤封装起来，抽象出 UI 组件初始化和更新部分，修改之后如下:12345678910111213141516171819202122@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder; if (convertView == null) &#123; // 抽象 `getLayout()` 方法来指定 UI 布局文件 convertView = LayoutInflater.from(mContext).inflate(getLayout(), parent, false); // 抽象初始化 UI 组件方法 holder = createViewHolder(); holder.initView(convertView); convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; // 抽象 UI 组件更新方法 holder.updateView(position, getItem(position)); return convertView;&#125;getView() 方法的封装就完成了封装 ViewHolderViewHolder 需要提供两个方法供 getView() 调用: initView()、updateView()，代码如下:123456789101112131415161718/** * 通用的 ViewHolder * Created by cengt on 8/4/16 10:05. */public abstract class CommonViewHolder&lt;T&gt; &#123; /** * 初始化 UI 组件 * @param view */ public abstract void initView(View view); /** * 更新 UI 组件 * @param position Item 的位置 * @param item */ public abstract void updateView(int position, T item);&#125;举个栗子使用的时候，只需要重写四个方法: createViewHolder()、getLayout()、initView()、updateView() 即可。1234567891011121314151617181920212223242526272829303132333435public class AppsAdapter extends CommonAdapter&lt;ResolveInfo&gt; &#123; private PackageManager mPackageManager; public AppsAdapter(final Context context, final PackageManager pm, final List&lt;ResolveInfo&gt; resolveInfos) &#123; super(context, resolveInfos); mPackageManager = pm; &#125; @Override protected CommonViewHolder&lt;ResolveInfo&gt; createViewHolder() &#123; return new ViewHolder(); &#125; @Override protected int getLayout() &#123; return R.layout.list_item_apps; &#125; private class ViewHolder extends CommonViewHolder&lt;ResolveInfo&gt; &#123; private TextView appName; private ImageView appIcon; @Override public void initView(View view) &#123; appName = (TextView) view.findViewById(R.id.app_name); appIcon = (ImageView) view.findViewById(R.id.app_icon); &#125; @Override public void updateView(int position, ResolveInfo item) &#123; appName.setText(item.loadLabel(mPackageManager)); appIcon.setImageDrawable(item.loadIcon(mPackageManager)); &#125; &#125;&#125;有图有真相，栗子效果:完整的代码CommonAdapter.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package cn.snaillauncher.adapter;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import java.util.List;/** * 通用的 Adapter * Created by cengt on 8/4/16 10:03. */public abstract class CommonAdapter&lt;T&gt; extends BaseAdapter &#123; protected Context mContext; protected List&lt;T&gt; mList; public CommonAdapter(Context context, List&lt;T&gt; list) &#123; mContext = context; mList = list; &#125; @Override public int getCount() &#123; return mList.size(); &#125; @Override public T getItem(int position) &#123; return mList.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; CommonViewHolder holder; if (convertView == null) &#123; // 抽象 `getLayout()` 方法来指定 UI 布局文件 convertView = LayoutInflater.from(mContext).inflate(getLayout(), parent, false); // 抽象初始化 UI 组件方法 holder = createViewHolder(); holder.initView(convertView); convertView.setTag(holder); &#125; else &#123; holder = (CommonViewHolder) convertView.getTag(); &#125; // 抽象 UI 组件更新方法 holder.updateView(position, getItem(position)); return convertView; &#125; /** * 创建 ViewHolder 对象 * @return ViewHolder 对象 */ protected abstract CommonViewHolder createViewHolder(); /** * 绑定 ListView Item 的布局文件 * @return 布局文件的资源 ID */ protected abstract int getLayout();&#125;CommonViewHolder.java12345678910111213141516171819202122package cn.snaillauncher.adapter;import android.view.View;/** * 通用的 ViewHolder * Created by cengt on 8/4/16 10:05. */public abstract class CommonViewHolder&lt;T&gt; &#123; /** * 初始化 UI 组件 * @param view */ public abstract void initView(View view); /** * 更新 UI 组件 * @param position Item 的位置 * @param item */ public abstract void updateView(int position, T item);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ListView</tag>
        <tag>BaseAdapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客开通啦~]]></title>
    <url>%2F2016%2F07%2F20%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E9%80%9A%E5%95%A6%2F</url>
    <content type="text"><![CDATA[我的个人的博客终于开通啦~ 选择了 Hexo + Markdown 搭建, 托管于 Coding.net, 以下简单地记录了下搭建的过程.简介Hexo 是一个快速、简介且高效的博客框架, 使用 Node.js 带来了超快的生成速度, 支持 Markdown 语法, 拥有丰富的插件, 部署方便, 只需要一条指令即可.Coding.net 是个代码托管平台, 类似于 Github, 由于众所周知的原因, Github 的访问速度比较慢, 所以选择了 Coding.net.步骤由于 Hexo 依赖于 Node.js, 所以首先安装 Node.js. (PS: 由于相关的网站都是国外的, 所以需要自备梯子)安装依赖软件1brew install -v autoconf automake libtool libpng jpeg安装 Node.js可以去 Node.js 的官网下载对应平台的安装文件进行安装, OS X 的平台可以选择使用 Homebrew 安装1brew install node安装 HexoHexo 使用的 Node.js 的包管理命令 npm 来安装1npm install hexo-cli -g初始化 Hexo123hexo init blogcd blognpm install本地预览1hexo serverHexo 会在本地启动一个 Web 服务器, 方便在本地实时预览, 地址为http://0.0.0.0:4000/, Hexo 会自动更新对文件所做的修改, 所以只需要让 Hexo 的 Web 服务器在后台运行即可愉快地写博客啦.1hexo server &gt; /dev/null &amp;常用命令新建一篇文章1hexo n 标题 // 等同于 hexo new 标题启动 Hexo 的 Web 服务器1hexo s // 等同于 hexo server生成静态网站资源1hexo g // 等同于 hexo generate发布网站1hexo d // 等同于 hexo deploy更多信息请参考官方文档主题主题选择了 NexT, 配置了部分第三方插件, 详细说明请参考主题的官方文档, 有中文版本, 很容易理解的.网站资源优化由于 Hexo 默认生成的页面是没有经过压缩优化的, 为了提升网站的加载速度和减少不必要的流量, 使用 Hexo 的插件 Hexo-all-minifier 来压缩页面, 可以压缩 HTML, CSS, JS 以及图片资源.OS X 平台需先安装以下依赖1brew install libtool automake autoconf nasm然后安装 Hexo-all-minifier1npm install hexo-all-minifier --save接着编辑 _config.yml 配置文件, 添加以下内容123456789101112131415161718192021222324html_minifier: enable: true exclude:css_minifier: enable: true exclude: - '*.min.css'js_minifier: enable: true mangle: true output: compress: exclude: - '*.min.js'image_minifier: enable: true interlaced: false multipass: false optimizationLevel: 2 pngquant: false progressive: false然后就没有然后了, Hexo 已经会自动压缩页面了, 压缩效果可以鼠标右键查看本页面的源码.站点发布注册账号在 Coding.net 上注册一个账号, 然后新建一个项目, 开启该项目的 Pages 服务.配置 SSH 的公钥使用 ssh-keygen 生成 SSH 的密钥1ssh-keygen -t rsa -C &#123;user_name&#125;默认生成在本地的 ~/.ssh 目录下, 将生成的公钥文件 id_rsa.pub 里面的内容复制到 Coding.net 的 账户 -&gt; SSH 公钥 处安装部署插件1npm install hexo-deployer-git --save发布信息配置编辑 _config.yml 文件, 修改 deploy 部分如下:1234deploy: type: git repo: git@git.coding.net:&#123;user_name&#125;/&#123;project_name&#125; branch: coding-pages{user_name} 为 Coding.net 的账号, {project_name} 为刚才新建的项目名称.发布1hexo d如果没有错误发生, 那就可以通过 http://{user_name}.coding.me/{project_name} 访问了参考链接使用Hexo建立独立博客]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
